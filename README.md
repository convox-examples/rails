# Rails on Convox Example

This repository contains an example Ruby on Rails 4.2 app configured for local development and deployment to Convox.

The following is a step-by-step walkthrough of how the app was configured and why.

## The Rails App

The [first commit](https://github.com/convox-examples/rails/commit/9ea994c33d8828686ed4622a7d40c4001fb19455) contains all the files generated by running `rails new example` via the rails 4.2.6 gem.

## Convox Init

The Convox CLI contains a command called `convox init`, which we used to generate the files in the [second commit](https://github.com/convox-examples/rails/commit/6ac2ccf0a15c69da2f6917eb46013be133a02434), `Dockerfile`, `docker-compose.yml`, and `.dockerignore`.

Since Convox uses Docker for containerization, these files are necessary to describe the application's containers and how to build them. The generated files are good defaults for most Rails apps, and they can also be edited to suit your specific needs.

### Dockerfile

#### convox/rails Docker image

The generated Dockerfile inherits from the [convox/rails Docker image](https://hub.docker.com/r/convox/rails/), which has all the packages and configuration necessary to run your Rails app both locally and in production. This includes:

* OS libraries to support PostgreSQL, MySQL, and sqlite3 databases
* nodejs for compiling Javascript assets
* nginx for proxying client connections
* a Convox-friendly nginx config file
* a convox.rb file for logging to STDOUT
* a bin/web script for booting the app

#### how Dockerfile describes the build

Starting from the `convox/rails` image, the [generated Dockerfile](https://github.com/convox-examples/rails/blob/master/Dockerfile) executes the remaining build steps that your Rails app needs. There are basically 3 steps in this process, and they are executed in a particular order to take advantage of Docker's build caching behavior.

1. `Gemfile` and `Gemfile.lock` are copied and `bundle install` is run. This happens first because it is slow and something that's done infrequently. After running once, this step will be cached unless the cache is busted by later edits to `Gemfile` or `Gemfile.lock`.

2. All the files necessary for the Rails asset pipeline are copied, and assets are built. Again, this is done early in the build process to optimize caching. The asset building step will only be run in the future if these files have changed.

3. The rest of the application source is copied over. These files will change frequently, so this step of the build will very rarely be cached.

### docker-compose.yml

The [docker-compose.yml](https://github.com/convox-examples/rails/blob/master/docker-compose.yml) file explains how to run the containers that make up your app. This generated file describes a `web` container which will be your main Rails web process. The various sections of the `web` configuration are described below:

#### build

```yaml
build: .
```

This entry declares that the web container should use an image built from the top level of your application directory using the Dockerfile found there.

#### labels

```yaml
labels:
  - convox.port.443.protocol=tls
  - convox.port.443.proxy=true
```

The labels section is used by Convox for configuration not covered by the official Compose spec. Here we're using it to configure how the load balancer handles traffic on port 443.

`convox.port.443.protocol=tls` means that the load balancer listens on port 443 in TLS mode, accepting encrypted traffic and using your application's certificate to decrypt the messages.

`convox.port.443.proxy=true` means that PROXY protocol TCP headers are injected into requests on port 443. These headers can then be used by nginx to set the HTTP headers your Rails application expects.

See the [load balancer documentation](https://convox.com/docs/load-balancers/) for more detailed info.

#### ports

```yaml
ports:
  - 80:4000
  - 443:4001
```

The ports section describes which ports your application listens on and which ports of the web container they map to. In this case the application is listening on ports 80 and 443 for http and https traffic. These requests get routed to the web container on ports 4000 and 4001, respectively. 

### .dockerignore

`convox init` also generates a [.dockerignore](https://github.com/convox-examples/rails/blob/master/.dockerignore) file that ignores files and directories not needed in the app's Docker image. It's important to have a good `.dockerignore` to keep images small and builds, pushes and pulls fast.

## Linking a database container

Up to this point the app has been using sqlite3 for its database. In a production environment, however, a database like PostgreSQL is more likely to be used. Linking a Postgres container to your app is pretty straightforward. Here's how we did it in this example.


### Update the app

First we removed the `sqlite3` gem and [added](https://github.com/convox-examples/rails/commit/838f207c06216e785d2348fdf1ca978185871a25) the `pg` gem.

Next we [removed](https://github.com/convox-examples/rails/commit/93e179ac8f13ee154d89a2e5ac77cb1493570625) the `config/database.yml` file. We'll be configuring the database via the `DATABASE_URL` environment variable going forward.

### Add a database container

We want to run a Postgres container for local development, so the next step is to [add](https://github.com/convox-examples/rails/commit/4aa191f5445171565cd383f965f9d608f9705e98) it to `docker-compose.yml`.

We define a new process called `database`, and use the `convox/postgres` image:

```yaml
database:
  image: convox/postgres
  ports:
    - 5432
```

We want the database to listen for connections on port 5432. When we deploy this app an internal TCP load balancer will be created to listen on that port.

### Persisting Data

Since the development database will run locally as a Docker container, it will start fresh with an empty database every time we run `convox start`. While this blank-slate behavior can be nice sometimes, in this case we want to keep the data in our database across starts. This can be accomplished using Docker volumes.

By [mounting a host volume onto our database container](https://github.com/convox-examples/rails/commit/6168ff7b756555674c652b40fa7205e9b1cb6284), we can keep many of the files the database creates. For `convox/postgres`, we need to mount a host volume to `/var/lib/postgresql/data` in the container.

The `database` section of `docker-compose.yml` now looks like:

```yaml
database:
  image: convox/postgres
  ports:
    - 5432
  volumes:
    - /var/lib/example/postgres:/var/lib/postgresql/data
```

**NOTE:** It's a good idea to use a host directory outside of the application directory for your data. This ensures your Docker volume won't have unwanted interactions with `convox start`'s built in code syncing. On Linux the `/var/lib` directory is a good place for this. Since our Rails app is called "example" here we've chosen `/var/lib/example/postgres` as our data directory on the host.

### Link database to web

Lastly, we need to link the database container to the web container. We do this by adding a `links` section to `web`:

```yaml
links:
  - database
```

This will cause a `DATABASE_URL` environment variable to be injected into the `web` environment, which it will use to connect to the database. You can read more about container linking [here](https://convox.com/docs/linking/).

A linked container works well for local development. However, when you deploy this app, you'll want a "real" Postgres. To accomplish this you can provision an hosted Postgres instance via [convox services](https://convox.com/docs/postgresql/), [scale](https://convox.com/docs/scaling/) your `database` process count in your app to 0, and set the DATABASE_URL [environment variable](https://convox.com/docs/environment/) to point to the hosted Postgres.

## Running the app Locally

```bash
convox start
```

## Deploying the application

After [installing a Rack](https://convox.com/docs/installing-a-rack/):

```bash
convox apps create
convox deploy
```
